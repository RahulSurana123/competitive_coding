
/*



Maximum value of F(x)
You are provided with the two binary strings named 'S' and 'T' of length 'N' and 'M', respectively. You have to choose a subsequence 'G' of 'S' and a subsequence 'H' of 'T' such that the length of 'G' must be equal to the length of 'H'. There is a function 'F(X)' given such that:  
  
\(F(X) = 2*Len(X) / (1 + 2^{|X|})\)

 

Where:  
'X' = Binary string formed after converting 'G' and 'H' to binary integers and taking their XOR.  
'Len(X)' = Length of binary string 'X'.  
'|X|' = Integer value in decimal, represented by binary string 'X'.  

For Example:
If 'G = "10101"' and 'H = "11001"', then 'X' will be the XOR of 'G' and 'H' i.e '"1100"', further more 'Len(X) = 4' and '|X| = 12'.   

 

All you have to do is to find the maximum value of 'F(X)'.  

 

Note: 
A String is a subsequence of a given String, that is generated by deleting some character of a given string without changing its order. For instance, '"HClor"' is a subsequence of '"HiCounselor"' which has generated after deleting ''i', 'o', 'u', 'n', 's', and 'e''.  

 

Input Format :
The first line of each input has an integer 'TC' that represents the number of test cases.  
The first line of each test case have two integers 'N' and 'M' separated by a single space.    
The second line of each test case have two strings 'S' and 'T' separated by a single space.   

Output Format: 
Print the maximum possible value of 'F(X)'.  

 

Constraints:
\(1 \leq TC \leq 10^2\)  
\(1 \leq N, M \leq  10^4\)
  
Strings 'S' and 'T' will only contain characters ''0'' and ''1''.

Sample input 1
Copy
1
2 3  
10 011  
Sample output 1
Copy
2
Explanation
Select 'G' and 'H' as '"0"' from 'S' and 'T'. 

\(F(0) = 2*1 / (1 + 2^0) = 2\)

*/





#include<bits/stdc++.h>
#include<iostream>
using namespace std;

string lcs(string a, string b){
    int len = a.length();
    int m = -INT_MAX;
    string ans;
    int l = len;
    while(len > 0){
        for(int i = 0; i < l+1-len;i++){
            string c = a.substr(i,len);
            int k = c.length();
            if(k > m && b.find(c) != string::npos){
                ans = c;
                m = k;
            }
        }
        len--;
    }
    return ans;
}
string result;
void lc(int i,int j,string a, string b,int n,int m){
    if(i >= n || j >= m){
        return;
    }
    if(a[i] == b[j]){
        result += a[i];
        lc(i+1,j+1,a,b,n,m);
    }
    else{
        lc(i+1,j,a,b,n,m);
    }
    // cout <<result<<"\n"; 
    return;
}

int main(){
    int t;
    cin >> t;
    while(t--){
        int n,m;
        string s,t;
        cin >> n >> m;
        cin >> s >> t;
        result = "";
        lc(0,0,s,t,n,m);
        int ans = 2*result.length();
        cout << ans <<"\n";        
    }
}